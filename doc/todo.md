# Akela
* use hash table for type slots
* store the type context as a field in the syntax tree: type_context (value or pointer)
* wrap pointers
* new syntax tree
* move checks into their own functions
* run IR generation in same pass
* order independence of global variables
* cast numerical values

# Akela LLVM

# Akela Parse Test
* scan tree for types
* output unique types
* output tree with unique types

# Akela Run Test
* sub
* mult
* divide

# Centipede

# Cobble

# Coverage

# Dataframe

# JSON

# Lava

# Zinc
* convert os specific to generic functions
* support suite-level mute and solo

# Test

# Example
* read config
* parse
* run
* check difference
